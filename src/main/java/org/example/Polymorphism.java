package org.example;

public class Polymorphism {
    public static void main(String[] args){
        // Полиморфизм - позволяет разным сущностям выполнять одни и те же действия.
        // При этом неважно, как эти сущности устроены внутри и чем они различаются.

        // Для определения абстракций в java импользуются interface

        // interface декларирует методы, без описания их реализации,
        // так же он не имеет полей. Можно сказать, что интерфейс
        // определяет поведение объекта

        // Чтобы класс поддерживал интерфейс надо в его объявлении указать
        // class <Название класса> implements <Название интерфейса>
        // Один класс может поддерживать сразу несколько интерфейсов
        // implemet - осуществлять, то есть класс обязуется
        // реализовать методы, задекларированные в интерфейсе

        // Наследование(Расширение) классов в java реализуется с помощью
        // ключевого слово extends.
        // При наследовании от класса родителя(Супер класса), его
        // наследник получает все поля и методы класса родителя
        // При этом МДа не изменяются, то есть, private поля
        // остаются private. В таком случае для инициализации полей родительского
        // класса используется син-ис super([<значение1>, <значение2>, ...])

        //  МД protected - служит для обеспечения видимости классов, полей и
        //  методов внутри того же пакета
        //  и в подклассах (наследуемых классах),
        //  даже если они находятся в других пакетах.

        // При этом, как и в случае с интерфейсами в переменную типа класса
        // родителям можно присвоить переменную класса ребёнка. Так как
        // класс ребёнок "расширяет" класс родитель => есть все те же поля

        // Так же класс ребёнок может переопределять методы класса родителя

        // Р - родитель, П - ребёнок
        // У каждого класса есть своя таблица виртуальных методов
        // Позднее связывание - когда информация о вызываемом методе получается
        // непосредственно во время его вызова в процессе работы программы

        // Протектед методы составляют защищённый интерфейс класса,
        // Паблик методы составляют внешний интерфейс класса

        // Так же есть правило наследования, в котором МД методов и полей
        // Р не должны изменяться в П.

        // В java есть возможность создавать промежуточный вариант абстракции
        // между интерфейсом и классом - абстрактный класс
        // Он позволяет написать "сместь" класса и интерфейса, то есть
        // класс у которого будут поля и методы, но часть из этих методов
        // могут быть только задекларированы, с помощью КС abstract
        // Как только у класса есть хотя бы один абст-ый метод,
        // он должен тоже стать абс-ым

        // Абст-ый метод резервирует запись в таблице вирт. методов,
        // но не заполняет её

        // Абст-ые классы полезны, так как позволяют не размножать код

        // Смотря сейчас на интерфейс, можно сказать, что все методы
        // в нём имеют МД public abstract

        // МД default(Метод по умолчанию) - Он предоставляет реализацию по умолчанию
        // для любого класса. То есть, позволяет избегать необходимости изменять все
        // классы, которые реализуют этот интерфейс. В классе, который реализует
        // интерфейс с методами по умолчанию, вы можете их переопределить.

        // Так же java позволяет спускаться по линии наследования вниз
        // FileByteReader fileReader = new FileByteReader();
        // ByteReader reader = fileReader;
        // if (reader instanceof FileByteReader){
        //  FyleByteReader fileReader = (FileByteReader)reader;
        //  fileReader.printFileName();
        // }

        // В данном примере instanceof - проверяет, можно ли объекту первого типа(В данном случае ByteReader)
        // присвоить ссылку на объект второго типа(FileByteReader)

        // Начиная с новых версия джава код выше можно упростить
        // if (reader instanceof FileByteReader fileReader){
        //  fileReader.printFileName();
        // }
        // То есть, если присваивание выплнить можно, то мы сразу присвоим в fileReader

        // Интерфейсы, которые помечают наличие дополнительной функциональности(Расширяют уже имеющийся инт-йс)
        // называются маркирующими

        // МД final в описании метода говорит о том, что в наследниках данного класса данный метод нельзя переопределять
        // МД final в описании класса говорит о том, что от данного класса нельзя наследоваться

        // С помощью интерфейсом можно связать несколько сущностей на основе их поведения
    }
}
